# Тест Міллера-Рабіна

### Теорія

n - просте тоді і лише тоді, коли рішеннями x2 = 1 (mod n) є x = ±1. <br>
 
Таким чином, якщо n проходить тест Ферма, тобто a^(n−1) = 1, тоді ми перевіряємо ще щоб a^((n−1)/2) = ±1,
оскільки a^((n−1)/2) це квадратний корінь 1. <br>

Якщо говорити формально, то нехай 2^S буде найбільшим ступенем 2, що ділиться на n-1, тобто n−1=2^(S)q для
якогось непарного числа q. Кожне число із послідовності

a^(n−1) = a^((2^S)q), a^((2^S-1)q),…, aq.

Це квадратний корінь попереднього члена послідовності.

Тоді якщо n - просте число, то послідовність повинна починатися з 1 і кожне наступне число теж має бути 1,
або перший член послідовність може бути не дорівнює 1, але тоді він дорівнює -1.

Тест Міллера-Рабін бере випадкове a∈ Zn. Якщо вищезазначена послідовність не починається з 1, або перший член
послідовності не дорівнює 1 або -1 тоді n - не просте.

Виявляється, що для будь-якого складового n, включаючи числа Кармайкла, ймовірність пройти тест Міллера-Рабіна дорівнює
приблизно 1/4. (У середньому значно менше.) Таким чином, ймовірність того, що n пройде кілька прогонів тесту,
зменшується експоненційно.

Якщо n не проходить тест Міллера-Рабіна з послідовністю, що починається з 1, тоді у нас з'являється нетривіальний
квадратний корінь із 1 по модулю n, і ми можемо ефективно знаходити дільники n. Тому числа Кармайкла завжди зручно
розкладати на множники.

Коли тест застосовується до числа видів pq, де p і q – великі прості числа, вони не проходять тест Міллера-Рабіна
практично у всіх випадках, оскільки послідовність не починається з 1. Отже, так ми RSA зламати не зможемо.

### Практика

Реалізується так:

* Дано n, потрібно знайти s, що n – 1 = 2^(S)q для деякого непарного q.
* Візьмемо випадкове a ∈ {1,...,n−1}
* Якщо a^q = 1, то n проходить тест і ми припиняємо виконання.
* Для i = 0, ..., s−1 перевірити рівність a^((2^i)q) = −1. Якщо рівність виконується, n проходить тест
(Припиняємо виконання).
* Якщо жодна з вищенаведених умов не виконана, то n – складова.

# RSA

### Генерація ключів

Для того, щоб згенерувати пари ключів виконуються такі дії:

* Вибираються два великі прості числа p і q приблизно 512 біт завдовжки кожне
* Обчислюється їх добуток n=pq
* Обчислюється функція Ейлера phi(n)=(p-1)(q-1)
* Вибирається ціле число e, таке, що 1<e< phi(n) та e, взаємно просте з phi(n)
* За допомогою розширеного алгоритму Евкліда знаходиться число d, таке, що ed тотожно рівне 1 mod phi (n)
Число n називається модулем, а числа e і d — відкритою й секретною експонентами, відповідно. Пари чисел (n,e) є 
відкритою частиною ключа, а (n,d) — секретною. Числа p і q після генерації пари ключів можуть бути знищені, але в 
жодному разі не повинні бути розкриті.

### Шифрування

Припустимо, що Боб хотів би відправити повідомлення M Алісі. Спочатку він перетворює M в ціле число m так, щоб 0 ≤ m < n 
за допомогою узгодженого оборотного протоколу, відомого як схеми доповнення. Потім він обчислює зашифрований текст c, 
використовуючи відкритий ключ Аліси e, за допомогою рівняння:

c=m^{e} mod n.

### Розшифрування

Для розшифрування повідомлення Боба m Алісі потрібно обчислити таку рівність:

m=c^{d} mod n.

Неважко переконатися, що при розшифруванні відновиться вихідне повідомлення:

c^{d} тотожно рівне (m^{e})^{d} тотожно рівне m^{ed} mod {n}

З умови

e*d тотожно рівне 1 mod phi(n)

випливає, що

e*d = k * phi (n) + 1 для деякого цілого k, отже

m^{ed} тотожно рівне m^{k*phi(n)+1} mod {n}

Згідно з теоремою Ейлера:

m^{phi (n)} тотожно рівне 1 mod {n}

тому

m^{k*phi (n)+1} тотожно рівне m mod {n}
c^{d} тотожно рівне m mod {n}

# RSA OAEP

Классическая схема OAEP представляет собой двухъячеечную сеть Фейстеля, где в каждой ячейке данные преобразуются с 
помощью криптографической хеш-функции. На вход сеть получает сообщение с дописанными к нему проверяющими нулями и ключ 
— случайную строку.

В схеме используются следующие обозначения:

* n — число бит в подготавливаемом для асимметричного шифрования блоке.
* k_{0} и k_{1} — фиксированные протоколом целые числа.
* m — открытый текст сообщения, n-k_{0}-k_{1} - битная строка.
* G и H — криптографические хеш-функции, заданные протоколом.

## Шифрование

* Сообщению m дописывается k_{1} нулей, благодаря чему оно достигает n-k_{0} бит в длину.
* Генерируется случайная k_{0}-битная строка r.
* G расширяет k_{0} бит строки r до n-k_{0} бит.
* X=m00..0 xor G(r).
* H ужимает n-k_{0} бит X до k_{0} бит.
* Y=r xor H(X).
* Зашифрованный текст X||Y (or operation).

## Расшифрование

* Восстанавливается случайная строка r=Y xor H(X)
* Восстанавливается исходное сообщение как m00..0=X xor G(r)
* Последние k_{1} символов расшифрованного сообщения проверяются на равенство нулю. Если имеются ненулевые символы, то
сообщение подделано злоумышленником.
